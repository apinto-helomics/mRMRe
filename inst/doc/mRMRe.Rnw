%\VignetteIndexEntry{mRMRe: an R package for parallelized mRMR ensemble feature selection}
%\VignetteDepends{Rcpp}
%\VignetteSuggests{}
%\VignetteKeywords{}
%\VignettePackage{mRMRe}

\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{authblk}


\title{mRMRe: an R package for parallelized mRMR ensemble feature selection}
\author[1]{Nicolas De Jay}
\author[1]{Simon Papillon-Cavanagh}
\author[2]{Catharina Olsen}
\author[2]{Gianluca Bontempi}
\author[1]{Benjamin Haibe-Kains}
\affil[1]{Bioinformatics and Computational Biology Laboratory, Institut de recherches cliniques de Montr\'{e}al, Montreal, Quebec, Canada}
\affil[2]{Machine Learning Group, Universit\'{e} Libre de Bruxelles, Brussels, Belgium}

\SweaveOpts{highlight=TRUE, tidy=TRUE, keep.space=TRUE, keep.blank.space=FALSE, keep.comment=TRUE}

<<setup,echo=FALSE,results=hide>>=
options(keep.source=TRUE)
@

\begin{document}


\maketitle
\tableofcontents

%------------------------------------------------------------
\section{Introduction}
%------------------------------------------------------------

\textit{mRMRe} is an R package for parallelized mRMR ensemble feature selection.

%------------------------------------------------------------
\subsection{Installation}
%------------------------------------------------------------

\textit{mRMRe} requires that \textit{Rcpp} is installed. 
These should be installed automatically when you install \textit{mRMRe}. To install \textit{mRMRe}, source biocLite from CRAN.

<<install-pkg, eval=false>>=
install.packages("mRMRe")
@

Load \textit{mRMRe} into your current workspace:
<<loadlib,results=hide>>=
library(mRMRe)
@ 

Load the example dataset \textit{cgps} into your current workspace:
<<loadlib,results=hide>>=
data(cgps)
@

%------------------------------------------------------------
\section{Measures of Associtation}
%------------------------------------------------------------

%------------------------------------------------------------
\subsection{Mutual Information Matrix}
%------------------------------------------------------------

mRMRe offers a fully parallelized implementation of the Mutual Information Matrix. The method supports the following column types: "numeric", "ordered_factor" and "Surv".

<<mim,eval=FALSE>>=
## Test on a dummy dataset
library(survival)
dd <- data.frame("surv1"=Surv(runif(100), sample(0:1, 100, replace=TRUE)),
        "cont1"=runif(100),
        "cat1"=factor(sample(1:5, 100, replace=TRUE), ordered=TRUE),
        "surv2"=Surv(runif(100), sample(0:1, 100, replace=TRUE)),
        "cont2"=runif(100),
        "cont3"=runif(100),
        "surv3"=Surv(runif(100),
                sample(0:1, 100, replace=TRUE)),
        "cat2"=factor(sample(1:5, 100, replace=TRUE), ordered=TRUE))
print(head(dd))
build.mim(data=dd)

## Test on the 'cgps' dataset
data(cgps)
## The variables are all of continuous type
mim <- build.mim(data.frame(cgps_ic50, cgps_ge)) # Uses Spearman as correlation estimator
print(head(mim))
mim <- build.mim(data.frame(cgps_ic50, cgps_ge), uses_ranks=FALSE) # Uses Pearson as correlation estimator
print(head(mim))
@

%------------------------------------------------------------
\subsection{Correlations}
%------------------------------------------------------------
The mRMRe package offers an efficient, stratified and weighted implementation of the major correlation estimators (Cramer's V, C-Index, Pearson, Spearman).

<<correlations,eval=FALSE>>=
data(cgps)
# Compute c-index between feature 1 and 2
correlate(cgps_ge[,1],cgps_ge[,2], method="cindex")

# Compute Cramer's V
x <- sample(c(0, 1, 2), 100, replace=TRUE)
y <- sample(c(0, 1), 100, replace=TRUE)
correlate(x, y, method="cramer")

# Compute Pearson coefficient with random strata and sample weights
# between feature 1 and 2
strata <- sample(as.factor(c("STRATUM_1","STRATUM_2","STRATUM_3")), nrow(cgps_ge), replace=TRUE)
weights <- runif(nrow(cgps_ge))
correlate(cgps_ge[, 1], cgps_ge[, 2], strata=strata, weights=weights, method="pearson", bootstrap_count=1000)
@

%------------------------------------------------------------
\section{mRMR Feature Selection}
%------------------------------------------------------------

mRMRe offers a highly efficient feature selection mRMR implementation.  First, we parallelized crucial steps of the algorithm.
Second, we used a lazy implementation of the mutual information matrix.

%------------------------------------------------------------
\subsection{Classic mRMR}
%------------------------------------------------------------

Here is an example of the classic mRMR feature selection.

<<classic.mRMR,eval=FALSE>>=
data(cgps)

data <- data.frame(target=cgps_ic50, cgps_ge)
mRMR.classic(data, 1, 30)
@

%------------------------------------------------------------
\subsection{Ensemble mRMR}
%------------------------------------------------------------

Our ensemble approach allows to create a tree-like set of solutions of non redundant mRMR solutions.  
The topology of the ensemble tree is user defined throught the \textit{levels} parameter.
A binary tree of depth 10 can be generated with \textit{levels=rep(2,10)}, therefore creating 2^10 mRMR solutions.

<<ensemble.mRMR,eval=FALSE>>=
data(cgps)

data <- data.frame(target=cgps_ic50, cgps_ge)
mRMR.ensemble(data, 1, rep.int(1, 30)) # For mRMR.classic-like results
mRMR.ensemble(data, 1, c(5:1, 4))
@

%------------------------------------------------------------
\section{Causality Inference}
%------------------------------------------------------------

The mRMRe package allows one to infer causality through the use of the Co-information lattice method.

<<causality,eval=FALSE>>=
data(cgps)

data <- data.frame(target=cgps_ic50, cgps_ge)
ensemble <- mRMR.ensemble(data, 1, c(10, 5, rep(1, 5)))
compute.causality(ensemble)
compute.causality(data=data, target_index=1, mim=NULL, solutions=ensemble$paths, estimator="spearman")
@

%------------------------------------------------------------
\section{Utilities}
%------------------------------------------------------------

In order to allow for full user control, mRMRe allows its users to set the number of threads it will
use for computations.  One should consider using the following method to avoid crowding computing clusters.

<<utils,eval=FALSE>>=
data(cgps)

set.thread.count(4)
mim <- build.mim(data.frame(target=cgps_ic50, cgps_ge))
head(mim)
@

\end{document}
